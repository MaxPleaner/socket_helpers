{"name":"Socket helpers","tagline":"websocket helpers for rails","body":"# SocketHelpers\r\n\r\n### Installation:\r\n\r\n- install to system: `gem install socket_helpers;`\r\n- install with bundler: `gem 'socket_helpers'`\r\n\r\n### Usage (these instructions can be seen implemented in the [socket_helpers_example](http://github.com/maxpleaner/socket_helpers_example) repo\r\n\r\n- `rails new App; cd App;`\r\n- `rails g scaffold Todo content:string; rake db:migrate`\r\n- `echo -e \"\\n gem 'socket_helpers'\" >> Gemfile; bundle;`\r\n- add javascript requires to application.js\r\n  - `//= require websocket-rails/main`\r\n  - `//= require socket_helpers`\r\n- include the controller helpers to application_controller\r\n \r\n   ```ruby\r\n     class ApplicationController < ActionController::Base\r\n       include SocketHelpers::ControllerHelpers\r\n     end\r\n   ```\r\n\r\n- Remove the default scaffold routes (`resources :todos`). This gem supports only _query_ parameters, not _path_ parameters.\r\n  - i.e. parameters are never declared in the routes.rb file, but they are declared in controllers. For example, routes like `DELETE /todos/MY_TODO_ID` are not supported, but `DELETE /todos?id=MY_TODO_ID` are.\r\n\r\n- Create a HTML-serving endpoint `rails g controller HtmlPages root`\r\n- Create websocket API endpoints and write routes:\r\n   \r\n   ```ruby\r\n     # routes.rb\r\n     get \"/\", to: \"html_pages#root\"\r\n     post \"todos\", to: \"todos#create\"\r\n     delete \"todos\", to: \"todos#destroy\"\r\n   ```\r\n\r\n   ```ruby\r\n     # app/controllers/todos_controller.rb\r\n     class TodosController < ApplicationController\r\n       def create\r\n         todo = Todo.create(todo_params)\r\n         websocket_response(todo, \"create\")\r\n       end\r\n       def destroy\r\n         todo = Todo.find_by(id: params[:id])\r\n         todo.destroy\r\n         websocket_response(todo, \"destroy\")\r\n       end\r\n       def todo_params\r\n       end\r\n     end\r\n   ```\r\n- the first argument of `websocket_response` can be a single record or an array/query. The second can be either `create`, `destroy`, or `update`. The receiver-hooks for these events are automatically created by the javascript client. \r\n- use the DSL for HTML in html_pages/root.html.erb. See below for a list of HTML components available.\r\n\r\n    ```html\r\n      <h3>Create todo</h3>\r\n      <form action=\"todos\" method=\"POST\">\r\n        <input type=\"text\" name=\"content\" placeholder=\"content\">\r\n        <input type=\"submit\" value=\"submit\">\r\n      </form>\r\n      <div class=\"todo_index\">\r\n        <h3>Todos</h3>\r\n        <p template>\r\n          <span template-attr=\"content\"></span>\r\n          <form action=\"/todos\" method=\"POST\"\r\n            <input type=\"hidden\" name=\"_method\" value=\"DELETE\"\r\n            <input type=\"hidden\" name=\"id\" template-attr=\"id\"\r\n            <input type=\"submit\" value=\"remove\"></input>\r\n          </form>\r\n          <br>\r\n        </p>\r\n        </ul>\r\n      </div>\r\n      <div init=\"todo\">\r\n        <%= Oj.dump Todo.all %>\r\n      </div>\r\n    ```\r\n- This provides working 'index, 'create', and 'destroy' websocket functionality in quite few lines of HTML, which is mainly the point of this gem. 'update' is automatic as well. When a record is added to the page, a `record-id` attribute is automatically set to `<record_class>,<id>` on the newly-added template. This is used to lookup records. \r\n\r\n- `rails s;`, open [localhost:3000](http://localhost:3000)\r\n\r\n- List of HTML components\r\n  - elements with a class of `<model_name>-index` become lists, with elements auto-removed and added in response to websocket events. \r\n  - inside a `<model_name>-index` element, an element with a `template` attribute becomes the template for added records. These sections correspond to a single ActiveRecord class (underscore, singular i.e. `todo_list_item` for `TodoListItem`)\r\n  - inside a `[template]` element (i.e. `<div template></div>`), the `template-attr` attribute is used to establish two-way databinding on an element. Its value is the name of the attribute. This can be used to set the value of form inputs or to change text nodes.\r\n  - **all form submits are intercepted** by event listeners. They submit AJAX requests using the url in the form's `action` attribute and the method in the form's `method` attribute (i.e. `action=\"/todos\" method=POST\"`). This works for `GET` and `POST`, but Like normally in Rails, `PUT` and `DELETE` can be selected by adding a hidden input method i.e. `input type=\"hidden\" name=\"_method\" value=\"PUT\"`\r\n  - To submit an id with a form, bind a hidden attribute i.e. `<input type=\"hidden\" name=\"id\" template-attr='id'>`\r\n  - Outside of `[template]`s, binding tags are a bit more verbose. `<span binding-tag='todos,1,content'></span>` where the three comma-separated arguments are <model_class>, <id>, and <attribute>. Internally, `template-attr` tags are converted to `binding-tag` once new records are added to the page. \r\n\r\n- **Loading initial data on the page**\r\n  - Witout doing this, the page will be empty every time it is refreshed. The page needs to start out with a list of records loaded.\r\n  - Create an html element with an `init` attribute set to a model class, i.e. `todo`. This element will be auto-hidden. In the html-serving controller method, make an instance variable for whatever data is going to be included. On the html page, set the content of the `[init]` element to a JSON stringified version of your instance variable.`\r\n\r\n- **Additional Helpers**\r\n  - you can make one html element toggle another open / close very easily.\r\n  - Just make them 'siblings (share the same parent element) and give the trigger a `toggles` attribute with a value set to the CSS selector of the target. The target will be initially closed. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}